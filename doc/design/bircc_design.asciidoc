Bircc Architecture And Design
=============================
:Author: Bjorn De Meyer
:Email: bjorn.de.meyer@gmail.com
:Date: 2014-01-13
:Revision: 0.1.0

Architecture
------------

Data Flow
~~~~~~~~~

Bircc is an ANSI C compiler, that performs the following operations in order:

1. Parse the command line and environment options and set up the data thus 
found into a compilation environment. Construct a list of files that 
have to be processed, and what has to be done with them.

2. From this list of files, for each file perform the needed operation. 
Let's assume that full compilation is required, other cases can be handled
by stopping halfway or calling by the linker, etc.

3. To compile a C file, first read it in completely. This requires more memory 
than line per line processing, but on contemporary systems this should be the
fastest approach. This sets up source data.

4. Trigraph replacement. Trigraphs are replaced by a simple search and replace 
in the source data.

5. Preprocessing. First, the preprocesor lexer tokenizes the source file, and produces a token list. The token list is then passed to the preprocessor parser
that parses the preprocessed data into a preprocessing AST. Finally the 
preprocessor interpreter is run on the preprocessor AST and any #included files 
are recursively handled starting from steps 3. to step 5. The result is a preprocessing AST that fully represents the "compilation unit" of the C program.
This AST is the collapsed into a token list again.

6. C lexing. The C lexer walks over the preprocessed token list, and further 
splits up and changes the type of the preprocessing tokens to C tokens. The 
result is a C token list.

7. C parsing. The C parser walks the C token list and constructs a C AST.

8. Optional first optimization pass. The C optimizer walks the C AST and 
removes any redundant statements, etc.

9. Intermediate Representation Generation. An intermediate representation or IR 
is generated for use by the back end. This IR is a list (XXX or a tree???) of 
simple statements, much like a virtual assembler, but already parsed. The IR 
could be generated by another front-end language that isn't C.

10. Optional IR optimization step. Peephole optimizations, etc can happen here.

11. The IR is passed to the selected back end. This could be an 
external assembler, or an internal code generator.

12. If an internal code generator is used, it transforms the IR into 
machine code in the desired binary file format lay-out (ELF, PE, etc).

13. The binary file(s) generated by the code generator are written out to the 
desired name and location.

14. Steps 2 though 13 are repeated for every file that needs compilation.


Components
~~~~~~~~~~

1. Command Line Parser
2. Environment Parser
3. Compilation Environment
4. Source File
5. Compilation Unit
6. Token list (Preprocessing / C)
7. AST (Preprocessing / C)
8. Preprocessor Lexer
9. Preprocessor Parser
10. Preprocessor Interpreter
11. C Lexer
12. C Parser
13. AST Optimizer
14. IR (Any language)
15. IR Optimizer
16. Code Generator
17. Output File



















